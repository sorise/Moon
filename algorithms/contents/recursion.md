### [递归 - 算法设计与分析](#)

**定义**：**程序调用自身的编程技巧称为递归**, 一个函数**直接**或者**间接**调用自己本身，这种函数称为递归函数。

------------------------



### [1. 基本思想](#)

而递归算法是把问题转化为规模缩小了的同类问题的子问题，然后调用递归函数表示问题的解，**其思想是将一个大型而且复杂的问题层层简化，转化为一个与原问题相似的规模较小且简单的子问题，通过多次调用子问题得到最终复杂问题的解**。

在递归调用的过程中，系统为每一层的返回点、局部变量等开辟了栈来存储，为了避免栈溢出的问题，递归需要有边界条件，必须有一个明确的递归出口。



**基本思路**: 将一个大型的复杂问题转化为一些与原问题相似的规模较小的问题来求解。

在实现递归函数之前，有两件重要的事情需要弄清楚:
* 递推关系：一个问题的结果与其子问题的结果之间的关系。
* 基本情况：不需要进一步的递归调用就可以直接计算答案的情况。可理解为递归跳出条件。



递归三要素：明确函数的功能+ 出口(递归终止条件) + 函数的等价关系



**遇到如下三种情况，可以考虑使用递归**

* 问题定义是递归的
* 解决问题时采用的数据结构是递归定义的
* 问题的求解过程是递归的



#### 1.1 递归解题的基本套路（四步曲）

1. 先定义一个函数，**明确这个函数的功能**，由于递归的特点是问题和子问题都会调用函数自身，所以这个函数的功能一旦确定了， 之后只要找寻问题与子问题的递归关系即可
2. 接下来寻找问题与子问题间的关系（即**递推公式**），这样由于问题与子问题具有**相同解决思路**，只要子问题调用步骤 1 定义好的函数，问题即可解决。所谓的关系最好能用一个公式表示出来，比如 **f(n) = n \* f(n-)** 这样，如果暂时无法得出明确的公式，用伪代码表示也是可以的, 发现递推关系后，要寻找最终不可再分解的子问题的解，即（临界条件），确保子问题不会无限分解下去。由于第一步我们已经定义了这个函数的功能，所以当问题拆分成子问题时，子问题可以调用步骤 1 定义的函数，符合递归的条件（函数里调用自身）
3. 将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中
4. 最后也是很关键的一步，根据问题与子问题的关系，推导出时间复杂度,如果发现递归时间复杂度不可接受，则需**转换思路对其进行改造**，看下是否有更靠谱的解法



#### 1.2 递归存在的问题

- 递归调用层级太多，导致栈溢出问题
- 递归重复计算，导致效率低下



#### 1.3 时间优化策略：记忆化

递归是一种直观而有效的实现算法的方法。 但是，如果我们不明智地使用它，可能会给性能带来一些不希望的损失，例如重复计算。 在前面我们提到了帕斯卡三角的重复计算问题，其中一些中间结果被多次计算。

在本文中，我们将进一步研究递归可能出现的重复计算问题。 然后我们将提出一种常用的技术，称为记忆化（memoization），可以用来避免这个问题。



#### 1.4 空间优化策略：尾递归

**函数尾调用自身则成为尾递归**, 尾递归函数是递归函数的一种，其中**递归调用是递归函数中的最后一条指令,并且在函数中应该只有一次递归调用**。



尾递归的好处是，它可以**避免递归调用期间栈空间开销的累积**，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是**复用了当前的栈空间**），爽歪歪。

累加函数，我们使用尾递归来优化一下

```javascript
function add(n, sum){
    if(n <= 0) return sum
    return add(n-1, n + sum)
}
```



### 2. 相关题目



#### 1.1 [青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。



```cpp
public int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2)
}
```



#### 1.2 [整数划分问题](https://leetcode.cn/problems/integer-break/)

将正整数n表示成一系列正整数之和, 有两种需求，求有多少中划分、其次求划分结果。

例如正整数6有如下11种不同的划分：

6；

5+1；

4+2，4+1+1；

3+3，3+2+1，3+1+1+1；

2+2+2，2+2+1+1，2+1+1+1+1；    

1+1+1+1+1+1。

<img src="./assets/image-20230827201056860.png" alt="image-20230827201056860" width="400px" />

* 当**n=1**时 q(1,m)：表示是对1的划分，那么只有一种划分方式 1
* 当**m=1**时q(n,1)：当m=1时其实就是把让所有加数小于等于1，那就是所有加数都是1咯（不考虑负数），当然也只有一种划分方式
* 当**n==m**时q(n,n)：此时就是对n的划分出来的数没有限制，默认限制就是不大于n，此时划分的总类数要分两种情况才比较好解决：
	* 划分出来的数包含n（或m，因为n==m）:那只有一种方式 比如 6的划分 只有 6;一种方式
	* 划分出来的数不包含n（或m，因为n==m）:就可以认为是将6划分出来的数都小于6，其实就是都小于或等于5,接下来        其实就是求出来q(n,n-1)或者是q(n,m-1),此时n>m-1,放到递归方程里就是求解q(n,m) n>m
    综合起来 q(n,n)=1+q(n,m-1)
* 当**n>m**时：分两种情况，划分出来的列表中最大数等于m，或者最大数小于 即 **q(n-m, m) + q(n, m - 1)**。
* 当**n<m**时，比如n=6,m=7 求得就是6得划分数小于等于7的情况，其实就是求解小于等于6，**故此时情况就是求解 q(n,n)**;

  根据以上分析：


正整数n的划分数 p(n) = q(n,n)。 

```cpp
int divide_helper(int num, int biggest){
    if(num == 1 || biggest == 1) return 1;
    if( num == biggest ){
        return 1 + divide_helper(num, biggest - 1);
    }
    if(biggest > num) return divide_helper(num, num);
    if(num > biggest)
        return divide_helper(num, biggest - 1) + divide_helper(num - biggest, biggest);
}
```



#### 1.3 [全排列问题](https://leetcode.cn/problems/permutations/)

从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。**回溯法更好理解，分治递归较为困难！**



全排列递归定义：

设R={r1,r2,…,rn}是要进行排列的n个元素，Ri=R-{ri}。 集合X中元素的全排列记为perm(X)。 (ri)perm(X)表示在全排列perm(X)的每一个排列前加上前缀得到的排列。

R的[全排列](https://so.csdn.net/so/search?q=全排列&spm=1001.2101.3001.7020)可归纳定义如下： 

* 当n=1时，perm(R) = ( r )，其中r是集合R中唯一的元素； 
* 当n>1时，perm(R)由 (r1)perm(R1)，(r2)perm(R2)，…，(rn)perm(Rn)构成。



```cpp
class Solution {
private:
    vector<vector<int>> ans;
public:
    //k 当前第几位 n 总共多少数字  n 是内边界
    void permute_helper(vector<int>& nums, int k, int n){
        if (k == n){
            for (auto &v: nums) {
                std::cout << v << " ";
            }
            std::cout << "\n";
        }else{
            // (r1)perm(R1)，(r2)perm(R2)，…，(rn)perm(Rn)
            for (int i = k; i <= n; ++i) {
                std::swap(nums[k], nums[i]); 
                permute_helper(nums, k + 1, n);
                std::swap(nums[k], nums[i]);
            }
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        permute_helper(nums, 0, nums.size() - 1);
        return ans;
    }
};
```

