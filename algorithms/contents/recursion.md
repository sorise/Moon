### [递归 - 算法设计与分析](#)

**定义**：**程序调用自身的编程技巧称为递归**, 一个函数**直接**或者**间接**调用自己本身，这种函数称为递归函数。

------------------------



### [1. 基本思想](#)

而递归算法是把问题转化为规模缩小了的同类问题的子问题，然后调用递归函数表示问题的解，**其思想是将一个大型而且复杂的问题层层简化，转化为一个与原问题相似的规模较小且简单的子问题，通过多次调用子问题得到最终复杂问题的解**。

在递归调用的过程中，系统为每一层的返回点、局部变量等开辟了栈来存储，为了避免栈溢出的问题，递归需要有边界条件，必须有一个明确的递归出口。



**基本思路**: 将一个大型的复杂问题转化为一些与原问题相似的规模较小的问题来求解。

在实现递归函数之前，有两件重要的事情需要弄清楚:
* 递推关系：一个问题的结果与其子问题的结果之间的关系。
* 基本情况：不需要进一步的递归调用就可以直接计算答案的情况。可理解为递归跳出条件。



递归三要素：明确函数的功能+ 出口(递归终止条件) + 函数的等价关系



#### 1.1 递归解题的基本套路（四步曲）

1. 先定义一个函数，**明确这个函数的功能**，由于递归的特点是问题和子问题都会调用函数自身，所以这个函数的功能一旦确定了， 之后只要找寻问题与子问题的递归关系即可
2. 接下来寻找问题与子问题间的关系（即**递推公式**），这样由于问题与子问题具有**相同解决思路**，只要子问题调用步骤 1 定义好的函数，问题即可解决。所谓的关系最好能用一个公式表示出来，比如 **f(n) = n \* f(n-)** 这样，如果暂时无法得出明确的公式，用伪代码表示也是可以的, 发现递推关系后，要寻找最终不可再分解的子问题的解，即（临界条件），确保子问题不会无限分解下去。由于第一步我们已经定义了这个函数的功能，所以当问题拆分成子问题时，子问题可以调用步骤 1 定义的函数，符合递归的条件（函数里调用自身）
3. 将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中
4. 最后也是很关键的一步，根据问题与子问题的关系，推导出时间复杂度,如果发现递归时间复杂度不可接受，则需**转换思路对其进行改造**，看下是否有更靠谱的解法





#### 1.2 递归存在的问题

- 递归调用层级太多，导致栈溢出问题
- 递归重复计算，导致效率低下



#### 1.3 时间优化策略：记忆化

递归是一种直观而有效的实现算法的方法。 但是，如果我们不明智地使用它，可能会给性能带来一些不希望的损失，例如重复计算。 在前面我们提到了帕斯卡三角的重复计算问题，其中一些中间结果被多次计算。

在本文中，我们将进一步研究递归可能出现的重复计算问题。 然后我们将提出一种常用的技术，称为记忆化（memoization），可以用来避免这个问题。



#### 1.4 空间优化策略：尾递归

**函数尾调用自身则成为尾递归**, 尾递归函数是递归函数的一种，其中**递归调用是递归函数中的最后一条指令,并且在函数中应该只有一次递归调用**。



尾递归的好处是，它可以**避免递归调用期间栈空间开销的累积**，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是**复用了当前的栈空间**），爽歪歪。

累加函数，我们使用尾递归来优化一下

```javascript
function add(n, sum){
    if(n <= 0) return sum
    return add(n-1, n + sum)
}
```



### 2. 相关题目



#### 1.1 [青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。



```cpp
public int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2)
}
```

